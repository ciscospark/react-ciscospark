/* eslint complexity: ["error", 14] */
import {fromJS, Map, OrderedMap} from 'immutable';

import {
  ACKNOWLEDGE_ACTIVITY,
  ADD_ACTIVITIES_TO_CONVERSATION,
  ADD_PARTICIPANT,
  ADD_PARTICIPANT_INFLIGHT,
  CREATE_CONVERSATION,
  CREATE_CONVERSATION_BEGIN,
  RECEIVE_MERCURY_ACTIVITY,
  RECEIVE_MERCURY_COMMENT,
  REMOVE_PARTICIPANT,
  REMOVE_PARTICIPANT_INFLIGHT,
  RESET_CONVERSATION,
  UPDATE_CONVERSATION_STATE,
  ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION
} from './actions';

import {filterActivities, normalizeActivities, normalizeActivity} from './helpers';

export const initialState = fromJS({
  activities: new OrderedMap(),
  id: null,
  inFlightParticipants: {
    adding: new Map(),
    removing: new Map()
  },
  lastAcknowledgedActivityId: null,
  participants: [],
  lastAcknowledgedCardActionActivity: null,
  status: {
    addParticipantError: null,
    isFetching: false,
    isListeningToMercury: false,
    isLoaded: false,
    isLoadingHistoryUp: false,
    isLoadingMissing: false,
    isLocked: true,
    isModerator: false,
    isOneOnOne: null,
    error: null,
    removeParticipantError: null
  }
});

function receiveMercuryActivity(state, action) {
  let activities = state.get('activities');
  let participants = state.get('participants');
  const {activity} = action.payload;
  const {verb} = activity;

  if (verb === 'delete') {
    // Find activity that is being deleted and change it to a tombstone
    const deletedId = activity.object.id;

    activities = activities.map((activityItem) => {
      if (activityItem.id === deletedId) {
        return Object.assign({}, activityItem, {
          verb: 'tombstone'
        });
      }

      return activityItem;
    });
  }
  else if (verb === 'acknowledge') {
    // acknowledge is a read receipt. we need to update the participants who
    // are listed in this acknowledgement
    const actorId = activity.actor.id;

    participants = state.get('participants').map((participant) => {
      if (participant.get('id') === actorId) {
        return participant
          .setIn(['roomProperties', 'lastSeenActivityUUID'], activity.object.id)
          .setIn(['roomProperties', 'lastSeenActivityDate'], activity.published);
      }

      return participant;
    });
  }

  return state.set('activities', activities).set('participants', participants);
}

export default function reducer(state = initialState, action) {
  switch (action.type) {
    case ACKNOWLEDGE_ACTIVITY: {
      return state.set('lastAcknowledgedActivityId', action.payload.activity.id);
    }
    case ADD_ACTIVITIES_TO_CONVERSATION: {
      const filteredActivities = normalizeActivities(filterActivities(action.payload.activities));
      const addedActivities = new OrderedMap(filteredActivities.map((activity) => [activity.url, activity]));
      let activities = state.get('activities').mergeDeep(addedActivities);

      activities = activities.sortBy((activity) => activity.published);

      return state.set('activities', activities);
    }

    case ADD_PARTICIPANT: {
      const participants = state.get('participants').push(fromJS(action.payload.participant));

      return state
        .set('participants', participants)
        .removeIn(['inFlightParticipants', 'adding', action.payload.participant.id])
      // In flight participants could be sideboarded and not have an id
        .removeIn(['inFlightParticipants', 'adding', action.payload.participant.emailAddress]);
    }

    case ADD_PARTICIPANT_INFLIGHT: {
      const {participant} = action.payload;

      return state.setIn(['inFlightParticipants', 'adding', participant.id], participant);
    }

    case CREATE_CONVERSATION_BEGIN: {
      return state.setIn(['status', 'isFetching'], true);
    }

    case CREATE_CONVERSATION: {
      const {
        defaultActivityEncryptionKeyUrl,
        avatar,
        displayName,
        id,
        kmsResourceObjectUrl,
        locusUrl,
        participants,
        tags,
        published,
        url,
        lastReadableActivityDate,
        teams,
        status
      } = action.payload.conversation;

      const rawActivities = action.payload.conversation.activities.items;
      const conversationActivities = normalizeActivities(filterActivities(rawActivities));

      let activities = new OrderedMap(conversationActivities.map((activity) => [activity.url, activity]));

      activities = activities.sortBy((activity) => activity.published);

      return state
        .set('activities', activities)
        .mergeDeep({
          avatar,
          displayName,
          defaultActivityEncryptionKeyUrl,
          id,
          kmsResourceObjectUrl,
          locusUrl,
          url,
          published,
          tags,
          lastReadableActivityDate,
          teams,
          status: Object.assign({}, status, {
            error: null,
            isFetching: false,
            isLoaded: true
          }),
          participants: participants.items
        });
    }

    case RECEIVE_MERCURY_ACTIVITY: {
      return receiveMercuryActivity(state, action);
    }

    case RECEIVE_MERCURY_COMMENT: {
      const receivedActivity = normalizeActivity(action.payload.activity);
      let activities = state.get('activities').set(receivedActivity.url, receivedActivity);

      activities = activities.sortBy((activity) => activity.published);

      return state.set('activities', activities);
    }

    case REMOVE_PARTICIPANT: {
      const participants = [];

      state.get('participants').forEach((p) => {
        if (p.get('id') !== action.payload.participant.id) {
          participants.push(p);
        }
      });

      return state
        .set('participants', fromJS(participants))
        .removeIn(['inFlightParticipants', 'removing', action.payload.participant.id]);
    }

    case REMOVE_PARTICIPANT_INFLIGHT: {
      const {participant} = action.payload;

      return state.setIn(['inFlightParticipants', 'removing', participant.id], participant);
    }

    case RESET_CONVERSATION: {
      return initialState;
    }

    case UPDATE_CONVERSATION_STATE: {
      return state.mergeIn(['status'], action.payload.conversationState);
    }

    case ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION: {
      return state.set('lastAcknowledgedCardActionActivity', action.payload.actionSubmitAcknowledgeObject);
    }

    default: {
      return state;
    }
  }
}
