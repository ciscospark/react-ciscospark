import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';
import {compose, lifecycle, withHandlers} from 'recompose';

import {
  acceptIncomingCall,
  placeCall,
  declineIncomingCall,
  hangupCall,
  constructCallObject,
  CallRecord
} from '@ciscospark/redux-module-media';
import {
  NOTIFICATION_TYPE_OTHER,
  createNotification
} from '@ciscospark/react-container-notifications';
import {addError, removeError} from '@ciscospark/redux-module-errors';
import {constructHydraId, hydraTypes} from '@ciscospark/react-component-utils';

import messages from '../messages';
import {
  updateWidgetStatus,
  storeMeetDetails
} from '../actions';

import {toTypes} from './withToType';


function catchCallError(props) {
  return (e) => {
    const callErrorId = 'spark.call';
    const {formatMessage} = props.intl;
    const actionTitle = formatMessage(messages.okButtonLabel);
    let displayTitle;
    let displaySubtitle;
    switch (e.name) {
      case 'DevicesNotFoundError':
        displayTitle = formatMessage(messages.callErrorDeviceNotFound);
        break;
      case 'NotAllowedError':
        displayTitle = formatMessage(messages.callErrorNotAllowed);
        break;
      case 'SecurityError':
        displayTitle = formatMessage(messages.callErrorSecurity);
        break;
      default:
        displayTitle = formatMessage(messages.callErrorUnknownMessage);
        displaySubtitle = `(${e.name} ${e.message})`;
    }
    props.addError({
      actionTitle,
      code: e.name,
      id: callErrorId,
      displayTitle,
      displaySubtitle,
      onAction: () => props.removeError(callErrorId),
      temporary: true
    });
  };
}

function handleAnswer(props) {
  return () => {
    props.acceptIncomingCall(props.callInstance).catch(props.catchCallError);
  };
}

function handleDecline(props) {
  return () => {
    const {callInstance} = props;
    props.declineIncomingCall(callInstance);
  };
}

function handleHangup(props) {
  return () => {
    props.hangupCall(props.callInstance);
  };
}

function handleCall(props) {
  return () => {
    const {
      sparkInstance,
      widgetMeet
    } = props;
    const {
      toType,
      toValue,
      spaceId,
      userId
    } = widgetMeet;

    let destination = toValue;

    if (toType === toTypes.USERID) {
      destination = constructHydraId(hydraTypes.PEOPLE, userId);
    }
    else if (toType === toTypes.SPACEID) {
      destination = constructHydraId(hydraTypes.ROOM, spaceId);
    }

    props.placeCall(sparkInstance, {destination})
      .then((call) => {
        // Store id in meetWidget once we get it back from server
        call.once('change:locus', () => {
          if (call.locus.url) {
            props.storeMeetDetails({
              callId: call.locus.url,
              call: undefined
            });
          }
        });

        // Store temporary call object. Need better way to get user directly
        // into call experience
        const tempCall = constructCallObject(call);
        tempCall.isConnected = true;
        props.storeMeetDetails({call: CallRecord(tempCall)});
      })
      .catch(props.catchCallError);
    props.updateWidgetStatus({hasInitiatedCall: true});
  };
}

function handleCallNotification(props) {
  return (incomingCall, fromPersonName) => {
    const {
      intl,
      avatarImage
    } = props;
    const {formatMessage} = intl;
    const details = {
      username: fromPersonName,
      message: formatMessage(messages.incomingCallMessage),
      avatar: avatarImage
    };
    props.createNotification(incomingCall.id, NOTIFICATION_TYPE_OTHER, details);
  };
}

export default compose(
  connect(
    null,
    (dispatch) => bindActionCreators({
      createNotification,
      acceptIncomingCall,
      declineIncomingCall,
      placeCall,
      hangupCall,
      updateWidgetStatus,
      storeMeetDetails,
      addError,
      removeError
    }, dispatch)
  ),
  withHandlers({
    handleAnswer,
    handleDecline,
    handleHangup,
    handleCall,
    handleCallNotification,
    catchCallError
  }),
  lifecycle({
    componentWillReceiveProps(nextProps) {
      const {
        call,
        displayName,
        widgetMeet,
        currentUser,
        startCall,
        isIncoming
      } = nextProps;
      if (call) {
        const prevCall = this.props.call;

        // Check if this is a new initiated call and is incoming
        if (
          call.isInitiated &&
          (!prevCall || !prevCall.isInitiated) &&
          isIncoming
        ) {
          nextProps.handleCallNotification(call, displayName);
        }
      }

      if (
        (widgetMeet.toValue || call) && currentUser && !widgetMeet.status.hasOpenWithCall
        && (startCall === true || startCall === '' || startCall === 'true')
      ) {
        nextProps.updateWidgetStatus({hasOpenWithCall: true});
        nextProps.handleCall();
      }
    },
    componentWillUnmount() {
      if (this.props.isActive) {
        this.props.handleHangup();
      }
    }
  })
);
