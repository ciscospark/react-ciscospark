import moment from 'moment';
import {fromJS, OrderedMap} from 'immutable';

import {
  ADD_SPACE,
  UPDATE_SPACES_STATUS,
  UPDATE_SPACE_WITH_ACTIVITY,
  REMOVE_SPACE,
  STORE_SPACES,
  STORE_TEAMS,
  STORE_AVATAR,
  FETCHING_AVATAR
} from './actions';

export const initialState = fromJS({
  items: new OrderedMap(),
  avatars: {},
  teams: {},
  status: {
    isFetching: false,
    hasFetched: false
  }
});


export default function reducer(state = initialState, action) { // eslint-disable-line complexity
  switch (action.type) {
  case UPDATE_SPACES_STATUS:
    return state.mergeDeepIn([`status`], action.payload.status);

  case STORE_SPACES: {
    const spaces = new OrderedMap(action.payload.spaces.map((s) => [s.id, fromJS(s)]));
    return state.setIn([`status`, `hasFetched`], true)
      .mergeDeepIn([`items`], spaces.sortBy(sortByNewest))
      .mergeDeepIn([`teams`], action.payload.teams);
  }

  case STORE_TEAMS: {
    return state.mergeDeepIn([`teams`], action.payload.teams);
  }

  case UPDATE_SPACE_WITH_ACTIVITY: {
    const space = action.payload.space;
    let spaces = state.get(`items`);
    if (state.getIn([`items`, space.id])) {
      spaces = spaces.mergeDeepIn([space.id], space);
    }
    return state.set(`items`, spaces.sortBy(sortByNewest));
  }

  case ADD_SPACE: {
    const spaces = state.get(`items`)
      .mergeDeepIn([action.payload.space.id], action.payload.space)
      .sortBy(sortByNewest);
    return state.set(`items`, spaces);
  }

  case REMOVE_SPACE:
    return state.deleteIn([`items`, action.payload.id]);

  case FETCHING_AVATAR:
    return state.setIn([`avatars`, action.payload.spaceId], {});

  case STORE_AVATAR: {
    return state.setIn([`avatars`, action.payload.spaceId], fromJS(action.payload.avatar));
  }

  default:
    return state;
  }
}


/**
 * Sort helper to arrange spaces by descending activity date
 *
 * @param {Object} space
 * @returns {Boolean}
 */
function sortByNewest(space) {
  return -moment(space.get(`lastReadableActivityDate`)).format(`x`);
}
