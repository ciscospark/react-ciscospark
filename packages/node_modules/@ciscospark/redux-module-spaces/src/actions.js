import moment from 'moment';
import _ from 'lodash';
import {bufferToBlob} from '@ciscospark/react-component-utils';

export const STORE_SPACES = `spaces/STORE_SPACES`;
export const STORE_TEAMS = `spaces/STORE_TEAMS`;
export const UPDATE_SPACES_STATUS = `spaces/UPDATE_SPACES_STATUS`;
export const UPDATE_SPACE_WITH_ACTIVITY = `spaces/UPDATE_SPACE_WITH_ACTIVITY`;
export const REMOVE_SPACE = `spaces/REMOVE_SPACE`;
export const ADD_SPACE = `spaces/ADD_SPACE`;
export const STORE_AVATAR = `spaces/STORE_AVATAR`;
export const FETCHING_AVATAR = `spaces/FETCHING_AVATAR`;

const TAG_ONE_ON_ONE = `ONE_ON_ONE`;
const TAG_LOCKED = `LOCKED`;


export function updateSpacesStatus(status) {
  return {
    type: UPDATE_SPACES_STATUS,
    payload: {
      status
    }
  };
}


/**
 * Updates the target space with incoming Mercury activity
 *
 * @export
 * @param {Object} activity
 * @param {Boolean} isSelf if actor is the same as this user
 * @param {Boolean} isReadable if the activity is a readable activity
 * @returns {Object} action
 */
export function updateSpaceWithActivity(activity, isSelf, isReadable = false) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  const space = {
    id: activity.target.id,
    latestActivity: activity,
    isLocked: activity.object.tags && activity.object.tags.includes(TAG_LOCKED)
  };

  if (isSelf) {
    space.lastSeenActivityDate = activity.published;
  }

  if (isReadable) {
    space.lastReadableActivityDate = activity.published;
  }

  return {
    type: UPDATE_SPACE_WITH_ACTIVITY,
    payload: {
      space
    }
  };
}

export function addSpace(space) {
  return {
    type: ADD_SPACE,
    payload: {
      space
    }
  };
}


export function removeSpace(id) {
  return {
    type: REMOVE_SPACE,
    payload: {
      id
    }
  };
}


function storeSpaces(spaces) {
  return {
    type: STORE_SPACES,
    payload: {
      spaces
    }
  };
}


function storeTeams(teams) {
  return {
    type: STORE_TEAMS,
    payload: {
      teams
    }
  };
}

function storeAvatar(spaceId, avatar) {
  return {
    type: STORE_AVATAR,
    payload: {
      spaceId,
      avatar
    }
  };
}

function fetchingAvatar(spaceId) {
  return {
    type: FETCHING_AVATAR,
    payload: {
      spaceId
    }
  };
}

/**
 * Fetches a list of spaces for the authenticated sparkInstance
 *
 * @export
 * @param {Object} sparkInstance
 * @returns {Function} thunk
 */

export function initialFetchSpaces(sparkInstance) {
  return (dispatch) => {
    dispatch(updateSpacesStatus({isFetching: true}));
    return dispatch(fetchSpaces(sparkInstance, {
      sinceDate: moment().subtract(`weeks`, 1).valueOf(),
      conversationsLimit: 10
    }))
    .then(({spaces}) => {
      const maxDate = _.first(_.sortBy(spaces, `lastReadableActivityDate`)).lastReadableActivityDate;
      return dispatch(fetchSpaces(sparkInstance, {
        maxDate,
        conversationsLimit: 50
      }));
    })
    .then(({teams}) => dispatch(fetchSpaces(sparkInstance, {
      conversationsLimit: 1000
    }, teams)))
    .then(({spaces}) => {
      dispatch(updateSpacesStatus({isFetching: false}));
      return spaces;
    });
  };
}


export function fetchSpaceAvatar(sparkInstance, space) {
  return (dispatch) => {
    const currentUserId = sparkInstance.internal.device.userId;
    dispatch(fetchingAvatar(space.id));
    if (space.type === `direct`) {
      // Support for direct messages with users who no longer exist
      if (space.participants.size > 1) {
        const otherUserId = space.participants.find((p) => p.id !== currentUserId).id;
        return sparkInstance.people.get(otherUserId)
          .then((person) => {
            dispatch(storeAvatar(space.id, {url: person.avatar}));
          });
      }
    }
    else if (space.avatar) {
      return sparkInstance.internal.conversation.download(space.avatar.files.items[0])
        .then((file) => {
          const {blob, objectUrl} = bufferToBlob(file);
          dispatch(storeAvatar(space.id, {url: objectUrl, blob}));
        });
    }
    return Promise.resolve();
  };
}


/**
 * Fetches single space from server
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} spaceId
 * @param {Object} teams
 * @returns {function} thunk
 */
export function fetchSpace(sparkInstance, spaceId, teams = {}) {
  return (dispatch) => sparkInstance.internal.conversation.get({
    id: spaceId
  }, {
    latestActivity: true,
    activitiesLimit: 1,
    participantAckFilter: `all`,
    includeParticipants: true
  }).then((space) => {
    const allTeams = Object.assign({}, teams, generateTeams([space]));
    const constructedSpace = constructSpace(space, allTeams);
    dispatch(storeTeams(allTeams));
    dispatch(addSpace(constructedSpace));
    return constructedSpace;
  });
}


/**
 * Fetches a list of spaces with options
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @param {Object} teams
 * @returns {Function} thunk
 */

function fetchSpaces(sparkInstance, options = {}, teams = {}) {
  const listOptions = {
    ackFilter: `noack`,
    uuidEntryFormat: true,
    personRefresh: true,
    latestActivity: ``,
    lastViewableActivityOnly: true,
    participantAckFilter: `all`,
    // Only need 2 for One on One conversations
    participantsLimit: 2
  };

  return (dispatch) => sparkInstance.internal.conversation
    .list(Object.assign({}, listOptions, options))
    .then((items) => {
      const allTeams = Object.assign({}, teams, generateTeams(items));
      const spaces = items.map((space) => constructSpace(space, allTeams));
      dispatch(storeTeams(allTeams));
      dispatch(storeSpaces(spaces));
      return {spaces, teams};
    });
}

/**
 * Creates team object to be stored
 *
 * @param {Object} space
 * @param {Object} teams
 * @returns {Object} formatted space object
 */
function constructSpace(space, teams) {
  const s = {
    latestActivity: space.activities.items[0],
    avatar: space.avatar,
    displayName: space.displayName,
    id: space.id,
    url: space.url,
    lastReadableActivityDate: space.lastReadableActivityDate,
    lastSeenActivityDate: space.lastSeenActivityDate,
    conversationWebUrl: space.conversationWebUrl,
    participants: space.participants.items,
    type: space.tags.includes(TAG_ONE_ON_ONE) ? `direct` : `group`,
    published: space.published,
    tags: space.tags
  };

  // Not storing team information if it hasn't been retrieved yet
  if (space.team && teams && teams[space.team.id]) {
    if (teams && teams[space.id]) {
      s.displayName = `General`;
    }
    const {teamColor, generalConversationUuid, id, archived} = space.team;
    s.team = {
      displayName: teams[generalConversationUuid],
      color: teamColor,
      generalConversationUuid,
      id,
      archived
    };
  }

  return s;
}


/**
 * Generate object of ids and team names from collection of spaces
 *
 * @param {Object} spaces
 * @returns {Object} teams
 */
function generateTeams(spaces) {
  const teams = {};
  spaces.forEach((s) => {
    if (s.team && s.team.generalConversationUuid === s.id) {
      teams[s.id] = s.displayName;
    }
  });
  return teams;
}
