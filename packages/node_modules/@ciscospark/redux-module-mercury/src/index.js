import {Map} from 'immutable';
import {metrics} from '@ciscospark/react-component-utils';

export const SET_CONNECTING = `mercury/SET_CONNECTING`;
export const SET_CONNECTED = `mercury/SET_CONNECTED`;

export const initialState = new Map({
  status: new Map({
    connected: false,
    connecting: false,
    hasConnected: false
  })
});

export default function reducer(state = initialState, action) {
  switch (action.type) {
  case SET_CONNECTING: {
    return state.setIn([`status`, `connecting`], action.payload);
  }
  case SET_CONNECTED: {
    let hasConnected = state.getIn([`status`, `hasConnected`]);
    if (action.payload) {
      hasConnected = true;
    }
    return state.setIn([`status`, `connected`], action.payload).setIn([`status`, `hasConnected`], hasConnected);
  }
  default: {
    return state;
  }
  }
}

function updateStatusConnecting(value) {
  return {
    type: SET_CONNECTING,
    payload: value
  };
}

function updateStatusConnected(value) {
  return {
    type: SET_CONNECTED,
    payload: value
  };
}

const metricName = {
  MERCURY_CONNECT_START: `mercuryConnection:start`,
  MERCURY_CONNECT_END: `mercuryConnection:end`,
  MERCURY_CONNECT_DURATION: `mercuryConnection:duration`
};

export function connectToMercury(spark) {
  return (dispatch) => {
    metrics.saveElapsedTime(metricName.MERCURY_CONNECT_START);
    metrics.sendTempMetric(metricName.MERCURY_CONNECT_START, spark);
    spark.mercury.on(`change:connecting`, () => {
      dispatch(updateStatusConnecting(spark.mercury.connecting));
    });
    spark.mercury.on(`change:connected`, () => {
      metrics.saveElapsedTime(metricName.MERCURY_CONNECT_END);
      metrics.sendTempMetric(metricName.MERCURY_CONNECT_END, spark);
      metrics.sendDurationMetric(
        metricName.MERCURY_CONNECT_DURATION,
        metricName.MERCURY_CONNECT_START,
        metricName.MERCURY_CONNECT_END,
        spark
      );
      dispatch(updateStatusConnected(spark.mercury.connected));
    });

    return spark.mercury.connect();
  };
}
