import {Component} from 'react';
import PropTypes from 'prop-types';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';

import {
  updateSparkStatus,
  registerDevice,
  storeSparkInstance
} from './actions';
import createSpark, {createSparkJwt} from './spark';

const metricName = {
  SPARK_AUTHENTICATED: {
    resource: 'spark',
    event: 'authentication',
    action: 'authenticated'
  },
  DEVICE_REGISTERED: {
    resource: 'device',
    event: 'registration',
    action: 'registered'
  }
};

const injectedPropTypes = {
  metrics: PropTypes.object.isRequired,
  spark: PropTypes.object.isRequired,
  storeSparkInstance: PropTypes.func.isRequired,
  updateSparkStatus: PropTypes.func.isRequired
};

const propTypes = {
  accessToken: PropTypes.string,
  guestToken: PropTypes.string,
  ...injectedPropTypes
};

const defaultProps = {
  accessToken: '',
  guestToken: ''
};

class SparkComponent extends Component {
  static setupDevice(spark, props) {
    const {
      authenticated,
      registered,
      registerError,
      registering
    } = props.spark.get('status').toJS();

    if (authenticated && !registered && !registering && !registerError) {
      props.registerDevice(spark);
    }
  }

  static listenToSparkEvents(spark, props) {
    const {metrics} = props;
    spark.listenToAndRun(spark, 'change:canAuthorize', () => {
      if (metrics && spark.canAuthorize) {
        metrics.sendElapsedTime(metricName.SPARK_AUTHENTICATED, spark);
      }
      props.updateSparkStatus({authenticated: spark.canAuthorize});
    });

    spark.listenToAndRun(spark, 'change:isAuthenticating', () => {
      props.updateSparkStatus({authenticating: spark.isAuthenticating});
    });

    spark.listenToAndRun(spark.internal.device, 'change:registered', () => {
      if (metrics && spark.internal.device.registered) {
        metrics.sendElapsedTime(metricName.DEVICE_REGISTERED, spark);
      }
      props.updateSparkStatus({registered: spark.internal.device.registered});
    });

    SparkComponent.setupDevice(spark, props);
  }

  componentDidMount() {
    const {props} = this;
    const {
      accessToken,
      guestToken
    } = this.props;

    const spark = props.spark.get('spark');

    function storeAndListen(sparkInstance) {
      props.storeSparkInstance(sparkInstance);
      SparkComponent.listenToSparkEvents(sparkInstance, props);
    }
    if (!spark) {
      if (guestToken) {
        createSparkJwt(guestToken, this.props).then(storeAndListen);
      }
      else {
        createSpark(accessToken, this.props).then(storeAndListen);
      }
    }
    else {
      SparkComponent.listenToSparkEvents(spark, props);
    }
  }

  componentWillReceiveProps(nextProps) {
    const spark = nextProps.spark.get('spark');
    SparkComponent.setupDevice(spark, nextProps);
  }

  shouldComponentUpdate(nextProps) {
    const {props} = this;
    return nextProps.spark !== props.spark;
  }

  render() {
    return null;
  }
}

SparkComponent.propTypes = propTypes;
SparkComponent.defaultProps = defaultProps;

export default connect(
  (state) => ({
    spark: state.spark
  }),
  (dispatch) => bindActionCreators({
    updateSparkStatus,
    registerDevice,
    storeSparkInstance
  }, dispatch)
)(SparkComponent);
