import {constructCallObject} from './helpers';

export const UPDATE_STATUS = 'media/UPDATE_STATUS';

export const DISMISS_INCOMING_CALL = 'media/DISMISS_INCOMING_CALL';
export const ANSWERED_INCOMING_CALL = 'media/ANSWERED_INCOMING_CALL';
export const STORE_CALL = 'media/STORE_CALL';
export const UPDATE_CALL_STATUS = 'media/UPDATE_CALL_STATUS';
export const UPDATE_CALL_ERROR = 'media/UPDATE_CALL_ERROR';
export const CONNECT_CALL = 'media/CONNECT_CALL';
export const REMOVE_CALL = 'media/REMOVE_CALL';

export const CHECKING_WEB_RTC_SUPPORT = 'media/CHECKING_WEB_RTC_SUPPORT';
export const UPDATE_WEBRTC_SUPPORT = 'media/UPDATE_WEBRTC_SUPPORT';


function updateCallStatus(call, eventName) {
  return {
    type: UPDATE_CALL_STATUS,
    payload: {
      id: call.locus && call.locus.url,
      call: constructCallObject(call),
      eventName
    }
  };
}

function updateCallError(call, error) {
  return {
    type: UPDATE_CALL_ERROR,
    payload: {
      id: call.locus && call.locus.url,
      call: constructCallObject(call),
      error
    }
  };
}

function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}


export function storeCall(call) {
  return {
    type: STORE_CALL,
    payload: {
      id: call.locus && call.locus.url,
      call: constructCallObject(call)
    }
  };
}

function connectCall(call) {
  return {
    type: CONNECT_CALL,
    payload: {
      id: call.locus && call.locus.url,
      call: constructCallObject(call)
    }
  };
}

function removeCall(callOrId) {
  let id = callOrId;
  // Get Id from locus if call object
  if (typeof callOrId === 'object') {
    id = callOrId.locus && callOrId.locus.url;
  }
  return {
    type: REMOVE_CALL,
    payload: {
      id
    }
  };
}


function checkingWebRTCSupport() {
  return {
    type: CHECKING_WEB_RTC_SUPPORT
  };
}


export function updateWebRTCSupport(supported) {
  return {
    type: UPDATE_WEBRTC_SUPPORT,
    payload: {
      supported
    }
  };
}

/**
 * Dismisses an incoming call, marking it so.
 * Note: This does not decline the call, just for tracking purposes
 * @param {string} callId
 * @returns {object}
 */
export function dismissIncomingCall(callId) {
  return {
    type: DISMISS_INCOMING_CALL,
    payload: {
      callId
    }
  };
}


function answeredIncomingCall(callId) {
  return {
    type: ANSWERED_INCOMING_CALL,
    payload: {
      callId
    }
  };
}

export function hangupCall(call) {
  return (dispatch) => {
    // Don't update call states after hangup
    call.off();
    return call.hangup().then(() => dispatch(removeCall(call)));
  };
}


function bindEvents(dispatch, call) {
  const updateCall = (callInstance, eventName) => dispatch(updateCallStatus(callInstance, eventName));

  call.once('active', () => dispatch(connectCall(call)));
  call.once('inactive', () => dispatch(hangupCall(call)));
  call.on('change:locus', () => updateCall(call, 'change:locus'));
  call.on('change:state', () => updateCall(call, 'change:state'));
  call.on('change:sendingAudio', () => updateCall(call, 'change:sendingAudio'));
  call.on('change:receivingAudio', () => updateCall(call, 'change:receivingAudio'));
  call.on('change:sendingVideo', () => updateCall(call, 'change:sendingVideo'));
  call.on('change:receivingVideo', () => updateCall(call, 'change:receivingVideo'));
  call.on('change:activeParticipantsCount', () => updateCall(call, 'change:activeParticipantCount'));
  call.on('remoteAudioMuted:change', () => updateCall(call, 'removeAudioMuted:change'));
  call.on('remoteVideoMuted:change', () => updateCall(call, 'removeVideoMuted:change'));
  call.on('remoteMediaStream:change', () => updateCall(call, 'remoteMediaStream:change'));
  call.on('localMediaStream:change', () => updateCall(call, 'localMediaStream:change'));
  call.on('change:joinedOnThisDevice', () => updateCall(call, 'change:joinedOnThisDevice'));
  call.on('membership:notified', () => updateCall(call, 'membership:notified'));
  call.on('membership:disconnected', () => updateCall(call, 'membership:disconnected'));
  call.on('membership:change', () => updateCall(call, 'membership:change'));
  call.on('memberships:add', () => updateCall(call, 'memberships:add'));
  call.on('memberships:remove', () => updateCall(call, 'memberships:remove'));
  call.on('membership:declined', () => {
    if (call.isCall && call.remoteMember && call.remoteMember.state === 'declined') {
      // Hang up if the remote person declines the call
      return dispatch(hangupCall(call));
    }
    return updateCall(call, 'membership:declined');
  });
  call.on('error', (err) => dispatch(updateCallError(call, err)));
}

/**
 * Process and store a call object from outside widgets
 * @param {Object} call
 * @returns {Function}
 */
export function storeExternalCall(call) {
  return (dispatch) => {
    bindEvents(dispatch, call);
    return dispatch(storeCall(call));
  };
}

/**
 * Call a user with an email address or userId
 *
 * @export
 * @param {String} data.destination
 * @param {Object} data.constraints
 * @param {Object} sparkInstance
 * @returns {Promise}
 */
export function placeCall(sparkInstance, {
  destination,
  constraints = {audio: true, video: true}
}) {
  return (dispatch) => {
    let call;
    try {
      call = sparkInstance.phone.dial(
        destination,
        Object.assign(
          constraints,
          {
            offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}
          }
        )
      );

      // Wait until locus returns with updated call object
      call.once('change:locus', () => {
        dispatch(storeCall(call));
        bindEvents(dispatch, call);
      });
    }
    catch (e) {
      // Ignore, will be caught on call.on('error')
    }
    return Promise.resolve(call);
  };
}

/**
 * Declines an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Thunk}
 */
export function declineIncomingCall(incomingCall) {
  return (dispatch) => {
    incomingCall.reject();
    dispatch(removeCall(incomingCall.locus.url));
    return Promise.resolve();
  };
}

/**
 * Accepts an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Promise}
 */
export function acceptIncomingCall(incomingCall) {
  return (dispatch) =>
    incomingCall.answer({
      offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}
    })
      .then(() => {
        bindEvents(dispatch, incomingCall);
        dispatch(connectCall(incomingCall));
        return incomingCall;
      });
}
/**
 * Listen for incoming calls and sets up call handling
 *
 * @export
 * @param {Object} sparkInstance
 * @returns {Promise}
 */
export function listenForIncomingCalls(sparkInstance) {
  return (dispatch) => {
    dispatch(updateStatus({isListening: true}));
    return sparkInstance.phone.on('call:incoming', (incomingCall) => {
      // If we make an outbound call via the widget, when the remote party answers,
      // we get a call:incoming notification when they connect
      if (incomingCall.direction === 'out') {
        return false;
      }

      return incomingCall.acknowledge()
        .then(() => {
          const removeIncoming = () => {
            incomingCall.off();
            return dispatch(removeCall(incomingCall, incomingCall.locus.url));
          };

          // If the remote party hangs up before we accept/decline
          incomingCall.once('inactive', removeIncoming);

          // If we rejected the call elsewhere, remove it
          incomingCall.on('membership:declined', () => {
            if (incomingCall.me.state === 'rejected') {
              dispatch(dismissIncomingCall(incomingCall.locus.url));
            }
          });

          incomingCall.on('membership:change', () => {
            // Once we are connected, our connected call state will handle disconnects
            if (incomingCall.me.state === 'connected') {
              dispatch(answeredIncomingCall(incomingCall.locus.url));
              // incomingCall.joinedOnThisDevice takes a few ticks so we have to
              // calculate it ourselves for now
              if (incomingCall.locus.self.deviceUrl !== sparkInstance.internal.device.url) {
                // We are not connected on this device, dismiss
                dispatch(dismissIncomingCall(incomingCall.locus.url));
              }
            }
          });
          dispatch(storeCall(incomingCall));
          return Promise.resolve(incomingCall);
        });
    });
  };
}

/**
 * Does a spark API request for existing calls and stores them
 * @param {object} sparkInstance
 * @returns {Promise}
 */
export function checkCurrentCalls(sparkInstance) {
  return (dispatch) => sparkInstance.phone.listActiveCalls()
    .then((results) => Promise.all(results.map((callObject) => {
      const removeCallObject = () => dispatch(removeCall(callObject));

      callObject.once('inactive', removeCallObject);

      return dispatch(storeCall(callObject));
    })));
}

/**
 * Check for browser webRTC support
 *
 *  @param {object} sparkInstance
 *  @returns {Promise}
 */
export function checkWebRTCSupport(sparkInstance) {
  return (dispatch) => {
    if (sparkInstance.phone) {
      dispatch(checkingWebRTCSupport());
      return sparkInstance.phone.isCallingSupported()
        .then((supported) => dispatch(updateWebRTCSupport(supported)));
    }
    return Promise.resolve();
  };
}
