import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';

import {initialState, CallRecord} from './reducer';
import * as actions from './actions';

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

let callInstance, callObject, mockSpark, store, callId;

describe('redux-module-media actions ', () => {
  beforeEach(() => {
    callInstance = {
      hangup: jest.fn(() => Promise.resolve()),
      acknowledge: jest.fn(() => Promise.resolve()),
      reject: jest.fn(() => Promise.resolve()),
      answer: jest.fn(() => Promise.resolve()),
      once: jest.fn(),
      on: jest.fn((eventName, callback) => Promise.resolve({eventName, callback})),
      off: jest.fn(),
      locus: {
        url: 'https://locusUrl',
        fullState: {
          lastActive: 'Sun Feb 18 2018 18:21:05 GMT'
        }
      },
      direction: '',
      joined: '',
      joinedOnThisDevice: '',
      state: 'active',
      status: '',
      receivingAudio: '',
      sendingAudio: '',
      sendingVideo: '',
      remoteMediaStream: '',
      localMediaStream: '',
      remoteAudioMuted: '',
      remoteVideoMuted: '',
      remoteAudioStream: '',
      remoteVideoStream: ''
    };

    callId = 'abc-123';
    callObject = new CallRecord({
      id: callId,
      instance: callInstance,
      locusUrl: callInstance.locus.url
    });

    mockSpark = {
      phone: {
        createLocalMediaStream: jest.fn(() => Promise.resolve()),
        dial: jest.fn(() => callInstance),
        listActiveCalls: jest.fn(() => Promise.resolve([callInstance])),
        on: jest.fn((eventName, callback) => Promise.resolve({eventName, callback})),
        isCallingSupported: jest.fn(() => Promise.resolve(true)),
        register: jest.fn(() => Promise.resolve())
      }
    };

    store = mockStore(initialState);
  });

  it('has exported actions', () => {
    expect(actions).toMatchSnapshot();
  });

  describe('#acceptIncomingCall', () => {
    it('can successfully accept an incoming call', () =>
      store.dispatch(actions.acceptIncomingCall(callObject))
        .then(() => {
          expect(callInstance.answer).toHaveBeenCalled();
          expect(store.getActions()).toMatchSnapshot();
        }));
  });

  describe('#checkCurrentCalls', () => {
    it('should check existing locus and store calls found', () => {
      store.dispatch(actions.checkCurrentCalls(mockSpark))
        .then(() => {
          expect(mockSpark.phone.listActiveCalls).toHaveBeenCalled();
          expect(store.getActions()).toMatchSnapshot();
        });
    });
  });

  describe('#checkWebRTCSupport', () => {
    it('can successfully check WebRTC support', () =>
      store.dispatch(actions.checkWebRTCSupport(mockSpark))
        .then(() => {
          expect(mockSpark.phone.isCallingSupported).toHaveBeenCalled();
          expect(store.getActions()).toMatchSnapshot();
        }));
  });

  describe('#declineIncomingCall', () => {
    it('can successfully decline an incoming call', () => {
      store.dispatch(actions.declineIncomingCall(callObject));
      expect(callInstance.reject).toHaveBeenCalled();
      expect(store.getActions()).toMatchSnapshot();
    });
  });

  describe('#dismissIncomingCall', () => {
    it('can successfully dismiss an incoming call', () => {
      store.dispatch(actions.dismissIncomingCall('abc-123'));
      expect(store.getActions()).toMatchSnapshot();
    });
  });

  describe('#hangupCall', () => {
    it('can successfully hangup active call', () =>
      store.dispatch(actions.hangupCall({call: callInstance, id: callObject.id}))
        .then(() => {
          expect(callInstance.off).toHaveBeenCalled();
          expect(callInstance.hangup).toHaveBeenCalled();
          expect(store.getActions()).toMatchSnapshot();
        }));
  });

  describe('#listenForCalls', () => {
    it('can successfully attach call:incoming listener', () =>
      store.dispatch(actions.listenForCalls(mockSpark))
        .then(() => {
          expect(mockSpark.phone.on).toHaveBeenCalled();
          // Promise.all does not guarantee execution order in node
          // so we need to just check that the .on events were attached
          // at some point
          const onEvents = mockSpark.phone.on.mock.calls.map((e) => e[0]);
          expect(onEvents).toContain('call:created');
          expect(onEvents).toContain('call:incoming');
          expect(store.getActions()).toMatchSnapshot();
        }));

    it('can successfully receive incoming call', () =>
      store.dispatch(actions.listenForCalls(mockSpark))
        .then(([{callback: incomingCallback}, {callback}]) => {
          expect(mockSpark.phone.on).toHaveBeenCalled();
          // Promise.all does not guarantee execution order in node
          // so we need to just check that the .on events were attached
          // at some point
          const onEvents = mockSpark.phone.on.mock.calls.map((e) => e[0]);
          expect(onEvents).toContain('call:created');
          expect(onEvents).toContain('call:incoming');
          return incomingCallback(callInstance)
            .then(() => {
              expect(callInstance.acknowledge).toHaveBeenCalled();
              return callback(callInstance)
                .then(() => {
                  expect(callInstance.once.mock.calls[0][0]).toBe('active');
                  expect(callInstance.once.mock.calls[1][0]).toBe('inactive');
                  expect(store.getActions()).toMatchSnapshot();
                });
            });
        }));

    it('can successfully handle created call', () =>
      store.dispatch(actions.listenForCalls(mockSpark))
        .then(([, {eventName, callback}]) => {
          expect(mockSpark.phone.on).toHaveBeenCalled();
          expect(eventName).toBe('call:created');
          return callback(callInstance)
            .then(() => {
              expect(callInstance.once.mock.calls[0][0]).toBe('active');
              expect(callInstance.once.mock.calls[1][0]).toBe('inactive');
              expect(store.getActions()).toMatchSnapshot();
            });
        }));

    it('should not store inactive created calls', () =>
      store.dispatch(actions.listenForCalls(mockSpark))
        .then(([, {eventName, callback}]) => {
          expect(mockSpark.phone.on).toHaveBeenCalled();
          expect(eventName).toBe('call:created');
          callInstance.state = 'inactive';
          return callback(callInstance)
            .then(() => {
              expect(store.getActions()).toMatchSnapshot();
            });
        }));
  });

  describe('#placeCall', () => {
    it('can successfully call a user with email', () => {
      const options = {
        destination: 'test@ciscospark.com',
        locusUrl: 'https://locusUrl'
      };
      store.dispatch(actions.placeCall(options, mockSpark))
        .then(() => {
          expect(mockSpark.phone.dial).toHaveBeenCalled();
          expect(store.getActions()).toMatchSnapshot();
        });
    });
  });

  describe('#registerClient', () => {
    it('can register a client with phone plugin', () => {
      store.dispatch(actions.registerClient(mockSpark))
        .then(() => {
          expect(mockSpark.phone.register).toHaveBeenCalled();
          expect(store.getActions()).toMatchSnapshot();
        });
    });
  });

  describe('#storeCall', () => {
    it('stores a call', () => {
      const destination = 'abc@123.net';
      store.dispatch(actions.storeCall({call: callInstance, destination, id: callId}));
      expect(store.getActions()).toMatchSnapshot();
    });
  });
});
