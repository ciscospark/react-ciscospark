import React, {Component, PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import autobind from 'autobind-decorator';

import LoadingScreen from '@ciscospark/react-component-loading-screen';
import Spinner from '@ciscospark/react-component-spinner';
import {fetchCurrentUser} from '@ciscospark/redux-module-user';
import {
  acknowledgeSpace,
  fetchSpace,
  fetchSpaceAvatar,
  removeSpace,
  initialFetchSpaces,
  updateSpaceWithActivity
} from '@ciscospark/redux-module-spaces';
import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import IncomingCall from '@ciscospark/react-component-incoming-call';

import messages from './messages';
import {getRecentsWidgetProps} from './selector';
import {
  updateWidgetStatus,
  updateWebRTCSupport,
  storeIncomingCall,
  deleteIncomingCall
} from './actions';
import SpacesList from './components/spaces-list';
import styles from './styles.css';
import {
  eventNames,
  constructMessagesEventData,
  constructRoomsEventData,
  constructMembershipEventData,
  constructCallEventData
} from './events';


export class RecentsWidget extends Component {

  componentWillReceiveProps(nextProps) {
    this.setup(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  componentWillUnmount() {
    this.props.sparkInstance.internal.mercury.disconnect().then(() => this.props.removeWidget());
  }

  @autobind
  setup(props) { // eslint-disable-line complexity
    const {
      sparkInstance,
      sparkState,
      mercury,
      metrics,
      user,
      spaces,
      spacesList,
      widgetRecents
    } = props;

    if (sparkInstance && sparkState.get(`authenticated`) && sparkState.get(`registered`)) {
      // Get current user details
      if (!user.getIn([`status`, `isFetchingCurrentUser`]) && !user.get(`currentUser`)) {
        props.fetchCurrentUser(sparkInstance);
      }

      // Setup Web Sockets
      if (!mercury.getIn([`status`, `hasConnected`])
        && !mercury.getIn([`status`, `connecting`])
        && !mercury.getIn([`status`, `connected`])
        && sparkInstance.internal.device.registered) {
        props.connectToMercury(sparkInstance);
      }

      // Grab spaces
      if (!spaces.getIn([`status`, `isFetching`])
        && mercury.getIn([`status`, `connected`])
        && !spaces.get(`items`).count()) {
        props.initialFetchSpaces(sparkInstance);
      }

      if (user.get(`currentUser`)
        && spaces.getIn(`status`, `hasFetched`)) {
        if (!widgetRecents.getIn([`status`, `isListeningForNewActivity`])) {
          this.listenForNewActivity(sparkInstance, props);
          this.listenForCall(sparkInstance, props);
        }
        spaces.get(`items`).forEach((s) => {
          if (!spaces.getIn([`avatars`, s.get(`id`)])) {
            props.fetchSpaceAvatar(sparkInstance, s.toJS());
          }
        });
      }

      if (sparkInstance && sparkInstance.phone && !widgetRecents.getIn([`status`, `hasCheckedWebRTCSupport`])) {
        props.updateWidgetStatus({hasCheckedWebRTCSupport: true});
        sparkInstance.phone.isCallingSupported().then((supported) => {
          props.updateWebRTCSupport(supported);
        });
      }

    }
    if (spacesList.count()) {
      metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
    }
  }

  @autobind
  handleNewActivity(activity) {
    const {
      props
    } = this;
    const {
      sparkInstance,
      spacesList
    } = props;

    let spaceId = activity.target && activity.target.id;

    // Handle spaceId if this is a completely new space
    if (!spaceId && activity.verb === `create`) {
      spaceId = activity.object.id;
    }
    const space = spacesList.get(spaceId);

    const processActivity = this.processActivity;
    if (space) {
      processActivity(activity, space);
    }
    else {
      // go retrieve the space if it doesn't exist
      props.fetchSpace(sparkInstance, spaceId)
        .then((newSpace) => {
          if (newSpace) {
            processActivity(activity, newSpace);
          }
        });
    }
  }

  @autobind
  processActivity(activity, space) { // eslint-disable-line complexity
    const {props, handleEvent} = this;
    const {
      user
    } = props;
    const currentUser = user.get(`currentUser`);
    const isSelf = activity.actor.id === currentUser.id;
    switch (activity.verb) {
    case `share`:
    case `post`: {
      const currentUserEmail = currentUser.email;
      const otherUser = space.participants
        .find((p) => p.emailAddress !== currentUserEmail);

      // Update space with newest post activity
      props.updateSpaceWithActivity(activity, isSelf, true);

      // Do not emit unread if current user created the message
      if (!isSelf) {
        handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(space, activity));
      }
      // Emit message:created event
      handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, otherUser));
      break;
    }
    case `lock`:
    case `unlock`: {
      props.updateSpaceWithActivity(activity, isSelf);
      break;
    }
    case `acknowledge`: {
      if (isSelf) {
        // update space with last acknowledgment if it's this user
        props.updateSpaceWithActivity(activity, isSelf);
        handleEvent(eventNames.SPACES_READ, constructRoomsEventData(space, activity));
      }
      break;
    }
    case `create`: {
      const constructedActivity = Object.assign({}, activity, {
        target: activity.object,
        object: {
          id: currentUser.id,
          emailAddress: currentUser.email
        }
      });
      handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(constructedActivity));
      break;
    }
    case `add`: {
      handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(activity));
      break;
    }
    case `leave`: {
      props.removeSpace(space.id);
      handleEvent(eventNames.MEMBERSHIPS_DELETED, constructMembershipEventData(activity));
      break;
    }
    default:
    }
  }

  /**
   * Setup listeners for new activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForNewActivity(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForNewActivity: true});
    return sparkInstance.internal.mercury.on(`event:conversation.activity`, (event) => this.handleNewActivity(event.data.activity));
  }

  /**
   * Setup listeners for call activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForCall(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForCall: true});
    return sparkInstance.phone.on(`call:incoming`, (call) => this.handleCall(call));
  }

  @autobind
  getSpaceFromCall(call) {
    return this.props.spacesList.get(call.locus.conversationUrl.split(`/`).pop());
  }

  @autobind
  handleCall(call) {
    const {
      props,
      handleEvent
    } = this;
    const {
      spacesList
    } = props;

    const space = spacesList.get(call.locus.conversationUrl.split(`/`).pop());
    // Only provide event if the call is direct
    if (space.type === `direct`) {
      call.acknowledge()
        .then(() => {
          // If call signals Disconnect we fire hangup and clean up
          call.once(`disconnected`, () => {
            call.off();
            return call.hangup().then(props.deleteIncomingCall);
          });
          // If call signals Connect we clean up
          call.once(`connected`, () => {
            call.off();
            props.deleteIncomingCall();
          });
          props.storeIncomingCall(call);

          handleEvent(eventNames.CALLS_CREATED, constructCallEventData(call, space));
        });
    }
  }

  @autobind
  handleAnswer() {
    const space = this.getSpaceFromCall(this.props.widgetRecents.get(`incomingCall`));
    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL_ANSWER,
      ...constructRoomsEventData(space)
    });
    this.props.deleteIncomingCall();
  }

  @autobind
  handleDecline() {
    const {
      props,
      getSpaceFromCall,
      handleEvent
    } = this;
    const call = props.widgetRecents.get(`incomingCall`);
    const space = getSpaceFromCall(call);

    call.reject()
      .then(() => {
        handleEvent(eventNames.SPACES_SELECTED, {
          action: eventNames.ACTION_CALL_REJECT,
          ...constructRoomsEventData(space)
        });
        props.deleteIncomingCall();
      });
  }

  @autobind
  handleSpaceClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    this.handleEvent(eventNames.SPACES_SELECTED, constructRoomsEventData(space));
  }

  @autobind
  handleSpaceCallClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    const roomData = constructRoomsEventData(space);
    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL,
      ...roomData
    });
  }


    /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undefined}
   */
  @autobind
  handleEvent(name, data) {
    const {
      onEvent,
      sparkInstance
    } = this.props;
    const logData = Object.assign({}, data);
    // Omit call objet from logger to prevent call range error
    if (data.call) {
      logData.call = `--- OMITTED ---`;
    }
    sparkInstance.logger.info(`event handler - ${name} - ${data.action}`, logData);
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  render() {
    const props = this.props;
    const {
      spacesList,
      spaces,
      widgetRecents
    } = props;
    const {formatMessage} = props.intl;
    const isFetchingSpaces = spaces.getIn([`status`, `isFetching`]);
    const incomingCall = widgetRecents.get(`incomingCall`);
    const hasWebRTCSupport = widgetRecents.getIn([`status`, `hasWebRTCSupport`]);

    if (spacesList && spacesList.count()) {

      if (incomingCall && hasWebRTCSupport) {
        const space = spacesList.get(incomingCall.locus.conversationUrl.split(`/`).pop());
        return (
          <IncomingCall
            answerButtonLabel={formatMessage(messages.answerButtonLabel)}
            avatarImage={space.avatarUrl}
            declineButtonLabel={formatMessage(messages.declineButtonLabel)}
            displayName={space.name}
            incomingCallMessage={formatMessage(messages.incomingCallMessage)}
            onAnswerClick={this.handleAnswer}
            onDeclineClick={this.handleDecline}
          />
        );
      }
      const handleCallClick = hasWebRTCSupport ? this.handleSpaceCallClick : undefined;
      return (
        <div className={classNames(`ciscospark-spaces-list-wrapper`, styles.spacesListWrapper)}>
          <SpacesList
            formatMessage={formatMessage}
            onCallClick={handleCallClick}
            onClick={this.handleSpaceClick}
            spaces={spacesList}
          />
          {
            isFetchingSpaces &&
            <div className={styles.spinner}>
              <Spinner bright />
            </div>
          }
        </div>
      );
    }

    return <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />;
  }
}

const injectedPropTypes = {
  mercury: PropTypes.object,
  sparkInstance: PropTypes.object,
  eventNames: PropTypes.object,
  user: PropTypes.object,
  spaces: PropTypes.object,
  spacesList: PropTypes.object,
  widgetRecents: PropTypes.object,
  connectToMercury: PropTypes.func,
  updateWidgetStatus: PropTypes.func,
  metrics: PropTypes.object
};

export const ownPropTypes = {
  muteNotifications: PropTypes.bool
};

RecentsWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};


function mapStateToProps(state) {
  return getRecentsWidgetProps(state);
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    acknowledgeSpace,
    connectToMercury,
    fetchCurrentUser,
    fetchSpace,
    fetchSpaceAvatar,
    removeSpace,
    initialFetchSpaces,
    updateWidgetStatus,
    updateSpaceWithActivity,
    storeIncomingCall,
    deleteIncomingCall,
    updateWebRTCSupport
  }, dispatch)
)(RecentsWidget);
