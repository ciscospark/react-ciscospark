import {connect} from 'react-redux';
import {compose, lifecycle} from 'recompose';
import {bindActionCreators} from 'redux';
import {addError, removeError} from '@ciscospark/redux-module-errors';
import {validateAndDecodeId} from '@ciscospark/react-component-utils';

import messages from '../messages';

import {destinationTypes} from '../';

import {ACTIVITY_TYPE_PRIMARY} from './activity-menu';

function checkForMercuryErrors(props) {
  const {
    errors,
    intl,
    mercury
  } = props;
  // Add Mercury disconnect error
  const mercuryError = 'mercury.disconnect';
  const isMercuryConnected = mercury.getIn(['status', 'connected']);
  const isMercuryDisconnected = !isMercuryConnected && mercury.getIn(['status', 'hasConnected']);
  const hasError = errors.get('hasError');
  const hasMercuryError = errors.get('errors').has(mercuryError);
  const hasNoMercuryError = !hasError || !hasMercuryError;
  if (isMercuryDisconnected && hasNoMercuryError) {
    // Create UI Error
    const {formatMessage} = intl;
    props.addError({
      id: mercuryError,
      displayTitle: formatMessage(messages.errorConnection),
      displaySubtitle: formatMessage(messages.reconnecting),
      temporary: true
    });
  }
  if (isMercuryConnected && hasMercuryError) {
    props.removeError(mercuryError);
  }
}

function checkForErrors(props) {
  const {
    activityTypes,
    currentUser,
    destination,
    destinationId,
    destinationType,
    errors,
    initialActivity,
    spaceId,
    sparkState,
    spark,
    toPersonEmail,
    toPersonId
  } = props;
  const {formatMessage} = props.intl;
  const registerErrorId = 'spark.register';
  if (sparkState.get('registerError') && (!errors.get('hasError') || !errors.get('errors').has(registerErrorId))) {
    const error = spark.get('error');
    let displaySubtitle = formatMessage(messages.unknownError);
    if (error.statusCode === 401) {
      displaySubtitle = formatMessage(messages.errorBadToken);
    }
    props.addError({
      id: registerErrorId,
      displayTitle: formatMessage(messages.unableToLoad),
      displaySubtitle,
      temporary: false,
      code: error.statusCode
    });
  }

  const missingDestinationErrorId = 'space.error.missingDestination';
  if (
    !destinationId && !destinationType && !toPersonEmail && !toPersonId && !spaceId &&
    (!errors.get('hasError') || !errors.get('errors').has(missingDestinationErrorId))
  ) {
    // No destination found
    props.addError({
      id: missingDestinationErrorId,
      displayTitle: formatMessage(messages.unableToLoad),
      displaySubtitle: formatMessage(messages.unknownDestination),
      temporary: false
    });
  }

  const toSelfErrorId = 'space.error.toSelf';
  if (
    destination &&
    currentUser && currentUser.id && currentUser.email &&
    (!errors.get('hasError') || !errors.get('errors').has(toSelfErrorId))
  ) {
    // Check for to user being self
    if (
      destination.type === destinationTypes.EMAIL && currentUser.email === destination.id
      || destination.type === destinationTypes.USERID && validateAndDecodeId(destination.id) === currentUser.id
    ) {
      props.addError({
        id: toSelfErrorId,
        displayTitle: formatMessage(messages.unableToLoad),
        displaySubtitle: formatMessage(messages.errorToSelf),
        temporary: false
      });
    }
  }

  if (activityTypes) {
    const invalidActivityId = 'ciscospark.container.space.error.invalidActivity';
    const defaultActivity = 'message';
    let validActivity = false;
    if (activityTypes.some((activity) => activity.name === initialActivity)
    || activityTypes.some((activity) => activity.name === defaultActivity)
    || activityTypes[0] && activityTypes[0].name && activityTypes[0].type === ACTIVITY_TYPE_PRIMARY
    ) {
      validActivity = true;
    }
    if (!validActivity && !errors.get('errors').has(invalidActivityId)) {
      props.addError({
        id: invalidActivityId,
        displayTitle: formatMessage(messages.disabledInitialActivity),
        temporary: false
      });
    }
    if (validActivity && errors.get('errors').has(invalidActivityId)) {
      props.removeError(invalidActivityId);
    }
  }
}

export default compose(
  connect(
    (state) => state,
    (dispatch) => bindActionCreators({
      addError,
      removeError
    }, dispatch)
  ),
  lifecycle({
    componentWillMount() {
      checkForErrors(this.props);
      checkForMercuryErrors(this.props);
    },
    componentWillReceiveProps: (nextProps) => {
      checkForMercuryErrors(nextProps);
      checkForErrors(nextProps);
    }
  })
);
