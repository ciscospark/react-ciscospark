import {createSelector} from 'reselect';
import {fromJS} from 'immutable';

import {SparkHttpError} from '@ciscospark/spark-core';
// Commented out for future error handling
// import {KmsError} from '@ciscospark/plugin-encryption';
// import {Exception} from '@ciscospark/common';

import messages from './messages';

const getWidget = (state) => state.widgetSpace;
const getSpark = (state) => state.spark;
const getMedia = (state) => state.media;
const getConversation = (state) => state.conversation;
const getUsers = (state) => state.user;
const getAvatars = (state) => state.avatar;
const getFormatMessage = (state, props) => props.intl.formatMessage;

export const getSpaceDetails = createSelector(
  [getWidget, getConversation, getUsers, getAvatars],
  // eslint-disable-next-line max-params,complexity
  (widget, conversation, users, avatars) => {
    const spaceDetails = widget.get(`spaceDetails`);
    if (conversation.get(`id`)) {
      let title = spaceDetails.get(`title`);
      let avatar = conversation.get(`avatar`);
      const currentUserEmail = users.get(`currentUser`).email;

      // Grab avatar if we're in a direct conversation
      if (spaceDetails.get(`type`) === `direct`) {
        const toUser = conversation.get(`participants`)
          .filter((p) => p.get(`emailAddress`) !== currentUserEmail).first();
        if (toUser) {
          title = toUser.get(`displayName`);
          avatar = avatars.getIn([`items`, toUser.get(`id`)]);
        }
      }

      return widget.get(`spaceDetails`).merge({
        avatar,
        title
      });
    }
    return spaceDetails;
  }
);

export const getActivityTypes = createSelector(
  [getWidget],
  (widget) => {
    const spaceType = widget.getIn([`spaceDetails`, `type`]);
    const activityTypes = widget.get(`activityTypes`);
    // Filter activity Type based on spaceType
    if (spaceType) {
      return activityTypes.filter((a) => a && a.get(`spaceTypes`).includes(spaceType));
    }
    return activityTypes;
  }
);

const getCall = createSelector(
  [getConversation, getMedia],
  (conversation, media) => media.getIn([`calls`, conversation.get(`locusUrl`)])
);

const getWidgetError = createSelector(
  [getWidget, getSpark, getFormatMessage],
  (widget, spark, formatMessage) => { // eslint-disable-line complexity
    const registerError = spark.getIn([`status`, `registerError`]);
    const widgetError = widget.getIn([`status`, `hasError`]);
    if (widgetError || registerError) {
      const error = widget.get(`error`) || spark.get(`error`);
      const errorTitle = formatMessage(messages.unableToLoad);
      let errorSubtitle = formatMessage(messages.unknownError);
      if (error instanceof SparkHttpError) {
        // error is shaped like an HttpResponse object
        if (error.statusCode === 401) {
          errorSubtitle = formatMessage(messages.errorBadToken);
        }
        else if (error.statusCode === 404) {
          errorSubtitle = formatMessage(messages.errorNotFound);
        }
      }
      // Commented out for future error handling
      // else if (error instanceof KmsError) {
      //   // err is a js-sdk error
      // }
      // else if (error instanceof Exception) {
      //   // err is a js-sdk error
      // }
      else if (error.name === `Bad Space Id`) {
        errorSubtitle = formatMessage(messages.badSpaceId);
      }
      return fromJS({
        hasError: true,
        errorTitle,
        errorSubtitle
      });
    }
    return fromJS({hasError: false});
  });

export const getSpaceWidgetProps = createSelector(
  [getWidget, getSpark, getMedia, getSpaceDetails, getActivityTypes, getWidgetError, getCall],
  (widget, spark, media, spaceDetails, activityTypes, widgetError, call) => ({ // eslint-disable-line max-params
    activityTypes,
    media,
    sparkInstance: spark.get(`spark`),
    sparkState: spark.get(`status`),
    spaceDetails,
    widgetError,
    widgetStatus: widget.get(`status`),
    call
  })
);

