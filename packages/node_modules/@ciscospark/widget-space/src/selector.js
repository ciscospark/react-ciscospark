import {createSelector} from 'reselect';
import {isUuid, constructHydraId, deconstructHydraId, hydraTypes} from '@ciscospark/react-component-utils';

import {destinationTypes} from './';

const getWidget = (state) => state.widgetSpace;
const getSpark = (state) => state.spark;
const getMedia = (state) => state.media;
const getConversation = (state) => state.conversation;
const getFeatures = (state) => state.features;
const getOwnProps = (state, ownProps) => ownProps;


// Injected by WithCurrentUser enhancer on widget base
const getCurrentUser = (state, ownProps) => ownProps.currentUser;

/**
 * Get the other user in a 1:1 conversation.
 * @param {conversation} conversation
 * @param {participant} currentUser
 * @returns {reselect.Selector}
 */
export const getToUser = createSelector(
  [getConversation, getCurrentUser],
  (conversation, currentUser) =>
    conversation
      .get('participants')
      .find((participant) => participant.get('id') !== currentUser.id)
);

export const getSpaceDetails = createSelector(
  [getWidget, getConversation, getCurrentUser, getToUser],
  (widget, conversation, currentUser, toUser) => {
    const spaceDetails = widget.get('spaceDetails');
    if (conversation.get('id') && currentUser) {
      let title = spaceDetails.get('title');
      let avatarId = conversation.get('id');
      // Grab avatar if we're in a direct conversation
      if (spaceDetails.get('type') === 'direct') {
        if (toUser) {
          title = toUser.get('displayName');
          avatarId = toUser.get('id');
        }
      }
      const toPerson = toUser ? toUser.get('id') : widget.get('toPerson');

      return widget.get('spaceDetails').merge({
        avatarId,
        title,
        toPerson
      });
    }
    return spaceDetails;
  }
);

export const getActivityTypes = createSelector(
  [getWidget, getFeatures, getOwnProps],
  (widget, features, ownProps) => {
    const {spaceActivities} = ownProps;
    const spaceType = widget.getIn(['spaceDetails', 'type']);
    const filteredActivityTypes = [];
    let activityTypes = widget.get('activityTypes').toJS();
    if (spaceActivities) {
      activityTypes = activityTypes.filter((a) => spaceActivities[a.name] !== false);
    }
    activityTypes.forEach((activityType) => {
      let isValid = true;
      // Filter activity Type based on spaceType
      if (spaceType && !activityType.spaceTypes.includes(spaceType)) {
        isValid = false;
      }
      // Filter activity type based on feature requirement
      if (activityType.feature && !activityType.feature.hide && !features.getIn(['items', activityType.feature.key])) {
        isValid = false;
      }
      // Hide flag on feature means to hide activity if feature is enabled
      if (activityType.feature && activityType.feature.hide && features.getIn(['items', activityType.feature.key])) {
        isValid = false;
      }
      if (isValid) {
        filteredActivityTypes.push(activityType);
      }
    });
    return filteredActivityTypes;
  }
);

const getCall = createSelector(
  [getConversation, getMedia],
  (conversation, media) => {
    const call = media.getIn(['byId', conversation.get('locusUrl')]);
    if (call && call.isDismissed) {
      return null;
    }
    return call;
  }
);

// to is used by the meet widget to determine call destination
const getTo = createSelector(
  [getWidget, getSpaceDetails],
  (widget, spaceDetails) => {
    let to;

    if (spaceDetails && spaceDetails.has('id')) {
      return spaceDetails.get('id');
    }
    const destination = widget.get('destination');
    if (destination) {
      switch (destination.type) {
        case destinationTypes.EMAIL:
          to = destination.id;
          break;
        case destinationTypes.SPACEID:
          if (isUuid(destination.id)) {
            to = constructHydraId(hydraTypes.ROOM, destination.id);
          }
          else {
            const {type} = deconstructHydraId(destination.id);
            if (type === hydraTypes.ROOM) {
              to = destination.id;
            }
          }
          break;
        case destinationTypes.USERID:
          if (isUuid(destination.id)) {
            to = constructHydraId(hydraTypes.PEOPLE, destination.id);
          }
          else {
            const {type} = deconstructHydraId(destination.id);
            if (type === hydraTypes.PEOPLE) {
              to = destination.id;
            }
          }
          break;
        default:
          break;
      }
      return destination.id;
    }
    // `to` should be an email or hydra id
    return to;
  }
);

export const getSpaceWidgetProps = createSelector(
  [getWidget, getSpark, getMedia, getSpaceDetails, getActivityTypes, getCall, getTo],
  (widget, spark, media, spaceDetails, activityTypes, call, to) => ({
    activityTypes,
    destination: widget.get('destination'),
    media,
    sparkInstance: spark.get('spark'),
    sparkState: spark.get('status'),
    spaceDetails,
    widgetStatus: widget.get('status'),
    call,
    // to is used by the meet widget to determine call destination
    to
  })
);
