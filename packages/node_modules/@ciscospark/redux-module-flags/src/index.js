const IN_FLIGHT_FLAG_ID = `IN_FLIGHT_FLAG_ID`;
const IN_FLIGHT_FLAG_URL = `IN_FLIGHT_FLAG_URL`;

export const ADD_FLAG_BEGIN = `flags/ADD_FLAG_BEGIN`;
export const ADD_FLAG = `flags/ADD_FLAG`;
export const REQUEST_FLAGS_BEGIN = `flags/REQUEST_FLAGS_BEGIN`;
export const REQUEST_FLAGS = `flags/REQUEST_FLAGS`;
export const REMOVE_FLAG = `flags/REMOVE_FLAG`;

function mapFlag(flag) {
  return {
    id: flag.id,
    url: flag.url,
    activityUrl: flag[`flag-item`]
  };
}

export const initialState = {
  flags: [],
  hasFetched: false,
  isFetching: false
};

// eslint-disable-reason Reducer Reduction Strategy incoming...
// eslint-disable-next-line complexity
export default function reducer(state = initialState, action) {
  switch (action.type) {

  case ADD_FLAG: {
    const {activity} = action.payload;
    let flags = [...state.flags];
    if (action.error) {
      // Remove in flight flag
      flags = flags.filter((flag) => flag.activityUrl !== activity.url);
    }
    else {
      const updatedFlag = mapFlag(action.payload.flag);
      flags = flags.map((flag) => {
        // Replace in flight activity flag with actual flag
        if (flag.activityUrl === updatedFlag.activityUrl) {
          return updatedFlag;
        }
        return flag;
      });
    }
    return Object.assign({}, state, {
      flags: [...flags]
    });
  }
  case ADD_FLAG_BEGIN: {
    const flag = {
      id: IN_FLIGHT_FLAG_ID,
      url: IN_FLIGHT_FLAG_URL,
      activityUrl: action.payload.activity.url
    };
    return Object.assign({}, state, {
      flags: [...state.flags, flag]
    });
  }

  case REQUEST_FLAGS_BEGIN:
    return Object.assign({}, state, {isFetching: true});
  case REQUEST_FLAGS: {
    const flagObject = Object.assign({}, state, {
      hasFetched: true,
      isFetching: false
    });
    if (action.error) {
      flagObject.error = action.payload;
    }
    else {
      const flags = action.payload.flags.map(mapFlag);
      flagObject.flags = [...flags];
    }
    return flagObject;
  }

  case REMOVE_FLAG: {
    const {flag} = action.payload;
    let flags = [...state.flags];
    if (action.error) {
      // Unable to delete flag, add it back in
      flags.push(flag);
    }
    else {
      flags = state.flags.filter((existingFlag) => existingFlag.id !== flag.id);
    }
    return Object.assign({}, state, {
      flags: [...flags]
    });
  }
  default: {
    return state;
  }
  }
}


function addFlagBegin(activity) {
  return {
    type: ADD_FLAG_BEGIN,
    payload: {
      activity
    }
  };
}

function addFlagSuccess(activity, flag) {
  return {
    type: ADD_FLAG,
    payload: {
      activity,
      flag
    }
  };
}

function addFlagError(activity, error) {
  return {
    type: ADD_FLAG,
    payload: {
      activity,
      error
    },
    error: true
  };
}

function requestFlagsBegin() {
  return {
    type: REQUEST_FLAGS_BEGIN
  };
}

function requestFlagsSuccess(flags) {
  return {
    type: REQUEST_FLAGS,
    payload: {
      flags
    }
  };
}

function requestFlagsError(error) {
  return {
    type: REQUEST_FLAGS,
    payload: error,
    error: true
  };
}

function removeFlagBegin(flag) {
  return {
    type: REMOVE_FLAG,
    payload: {
      flag
    }
  };
}

function removeFlagError(error, flag) {
  return {
    type: REMOVE_FLAG,
    payload: {
      error,
      flag
    },
    error: true
  };
}

/**
 * Fetches all of the current user's flags
 *
 * @param {any} spark
 * @returns {function}
 */
export function fetchFlags(spark) {
  return (dispatch) => {
    dispatch(requestFlagsBegin());
    return spark.internal.flag.list()
      .then((flags) =>
        dispatch(requestFlagsSuccess(flags))
      )
      .catch((error) =>
        dispatch(requestFlagsError(error))
      );
  };
}

/**
 * Flags a given activity. Updates state immediately then
 * adds flag details given from api
 *
 * @param {any} activity
 * @param {any} spark
 * @returns {function}
 */
export function flagActivity(activity, spark) {
  return (dispatch) => {
    dispatch(addFlagBegin(activity));
    return spark.internal.flag.create(activity)
      .then((flag) =>
        dispatch(addFlagSuccess(activity, flag))
      )
      .catch((error) =>
        dispatch(addFlagError(activity, error))
      );
  };
}

/**
 * Removes a flag from the server. Updates the state immediately
 * but re-adds it if the delete fails
 *
 * @param {any} flag
 * @param {any} spark
 * @returns {function}
 */
export function removeFlagFromServer(flag, spark) {
  return (dispatch) => {
    dispatch(removeFlagBegin(flag));
    return spark.internal.flag.delete(flag)
      .catch((error) => {
        dispatch(removeFlagError(error, flag));
      });
  };
}
