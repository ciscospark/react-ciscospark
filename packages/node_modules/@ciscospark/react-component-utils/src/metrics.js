const METRIC_NS = `ciscospark_widget_`;
const LOAD_START = `widget:ready`;

const metrics = {};
let metricsQueue = [];
const metricsCount = {};
/**
 * Temporarily save metric to sessionStorage
 * @param {string} key
 * @param  {any} data
 * @returns {null}
 */
export function saveTempMetric(key, data) {
  metrics[key] = data;
}

export function getTempMetric(key) {
  const data = metrics[key];
  return {key, data};
}

// Helpers for saving metrics to queue before Spark is ready to send metrics

export function saveMetricToQueue(key, data) {
  metricsQueue.push({key, data});
}

export function saveElapsedTimeToQueue(key) {
  const elapsedTime = getElapsedTime();
  saveMetricToQueue(key, elapsedTime);
}

export function sendMetricsInQueue(spark) {
  metricsQueue.forEach(({key, data}) => {
    sendPerfMetric({key, data}, spark);
  });
  metricsQueue = [];
}

/**
 * Immediately send metric
 * @param  {object} metric
 * @param  {string} metric.key
 * @param  {any} metric.data
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendPerfMetric({key, data, fields, tags}, spark) {
  try {
    const [name, action] = key.split(`:`);

    const count = metricsCount[key];
    if (count) {
      metricsCount[key] = count + 1;
    }
    else {
      metricsCount[key] = 1;
    }

    const formattedData = {
      type: [`operational`],
      tags: Object.assign({
        action
      }, tags),
      fields: Object.assign({
        protocol: window.location.protocol,
        hostname: window.location.hostname,
        pathname: window.location.pathname,
        widgetVersion: process.env.REACT_CISCOSPARK_VERSION,
        jsSdkVersion: spark.version,
        iteration: metricsCount[key],
        data
      }, fields)
    };
    return spark.metrics.submitClientMetrics(`${METRIC_NS}${name}`, formattedData);
  }
  catch (e) {
    return console.warn(`clientMetrics: ${key} metrics was not sent`, e); // eslint-disable-line no-console
  }
}

/**
 * Send metric stored in session
 * @param  {string} key
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendTempMetric(key, spark) {
  let metric = getTempMetric(key);
  metric = isNaN(metric) ? metric : Number(metric);
  return sendPerfMetric(metric, spark);
}

/**
 * Save start time
 * @param  {object} spark
 * @returns {null}
 */
export function saveAndSendLoadStart(spark) {
  const now = saveLoadStart();
  sendLoadStart(spark);
  return now;
}

/**
 * Send start time
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendLoadStart(spark) {
  const data = getTempMetric(LOAD_START);
  return sendPerfMetric(data, spark);
}

/**
 * Save start time
 * @returns {number} now
 */
export function saveLoadStart() {
  const now = window.performance.now();
  saveTempMetric(LOAD_START, now);
  return now;
}

function getElapsedTime() {
  const now = window.performance.now();
  const start = getTempMetric(LOAD_START).data;
  return start && now - start;
}

/**
 * Save time elapsed for event
 * @type {type}
 */

export function saveElapsedTime(key) {
  const elapsedTime = getElapsedTime();
  saveTempMetric(key, elapsedTime);
}

/**
 * Send time from starting load
 * @param  {string} key
 * @param  {object} spark
 * @param  {object} fields
 * @returns {Promise}
 */
export function sendElapsedTimeMetric(key, spark, fields) {
  let elapsedTime = getElapsedTime();
  if (!elapsedTime) {
    saveAndSendLoadStart(spark);
    elapsedTime = 0;
  }
  return sendPerfMetric({key, data: elapsedTime, fields}, spark);
}

export function sendDurationMetric(key, start, end, spark) {
  const startMetric = getTempMetric(start).data;
  const endMetric = getTempMetric(end).data;
  return sendPerfMetric({key, data: endMetric - startMetric}, spark);
}
