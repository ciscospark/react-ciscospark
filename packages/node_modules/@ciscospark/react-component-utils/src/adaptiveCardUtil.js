import * as AdaptiveCard from 'adaptivecards';
import MDTextInput from '@ciscospark/react-component-md-text-input';
import MDToggleInput from '@ciscospark/react-component-md-toggle-input';
import MDChoiceSetInput from '@ciscospark/react-component-md-choiceset-input';
import {parseMarkdown} from '@ciscospark/redux-module-activity';

import {CARD_ATTACHMENT_TYPE, TEXT_INPUT_ELEMENT, TOGGLE_INPUT_ELEMENT, CHOICE_SET_INPUT_ELEMENT} from './constants';

/* eslint no-param-reassign: 2 */
// eslint-disable-next-line valid-jsdoc
/**
 * It used to handle markdown
 * @param {string} text
 * @returns {object}
 */
AdaptiveCard.AdaptiveCard.onProcessMarkdown = function processMarkdown(text, result = {}) {
  try {
    const markedString = parseMarkdown(text);

    result.outputHtml = markedString !== null ? markedString : text;
    result.didProcess = true;
  }
  catch (err) {
    result.didProcess = false;
  }

  return result;
};

/**
 * It used to call momentum ui compoennts and returns patched adaptive card
 * @param {object} addChildNode
 * @returns {object}
 */
function getPatchedAdaptiveCard(addChildNode = null) {
  AdaptiveCard.AdaptiveCard.elementTypeRegistry.registerType(TEXT_INPUT_ELEMENT, () => new MDTextInput(addChildNode));
  AdaptiveCard.AdaptiveCard.elementTypeRegistry.registerType(
    TOGGLE_INPUT_ELEMENT, () => new MDToggleInput(addChildNode)
  );
  AdaptiveCard.AdaptiveCard.elementTypeRegistry.registerType(
    CHOICE_SET_INPUT_ELEMENT,
    () => new MDChoiceSetInput(addChildNode)
  );

  return AdaptiveCard;
}

/**
 * It will return the json object by taking the input string
 * @param {string} card
 * @param {object} sparkInstance
 * @returns {object}
 */
export function getCardConfig(card, sparkInstance) {
  try {
    return JSON.parse(card);
  }
  catch (err) {
    sparkInstance.logger.error('Failed to parse Adaptive Card', err);
  }

  return null;
}

/**
 * It will return the rendered adaptive card when message contains card
 * else returns display name
 * @param {array} cards
 * @param {string} displayName
 * @param {object} sparkInstance
 * @param {object} addChildNode
 * @returns {object}
 */
export function getAdaptiveCard(cards, displayName, sparkInstance, addChildNode = null) {
  // Parse the card for rendering
  try {
    const cardConfig = getCardConfig(cards[0]);
    const PatchedAdaptiveCard = getPatchedAdaptiveCard(addChildNode);
    const adaptiveCard = new PatchedAdaptiveCard.AdaptiveCard();

    adaptiveCard.parse(cardConfig);

    return adaptiveCard.render();
  }
  catch (err) {
    sparkInstance.logger.error('Failed to parse Adaptive Card', err);
  }

  return displayName;
}

/**
 * It will return the boolean value for adaptive card exists or not
 * @param {array} cards
 * @param {object} sparkInstance
 * @returns {boolean}
 */
export function hasAdaptiveCard(cards, sparkInstance) {
  if (Array.isArray(cards) && cards.length > 0) {
    const cardConfig = getCardConfig(cards[0], sparkInstance);

    return cardConfig !== null && cardConfig.type === CARD_ATTACHMENT_TYPE;
  }

  return false;
}
